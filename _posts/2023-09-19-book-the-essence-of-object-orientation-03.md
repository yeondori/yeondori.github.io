---
title: "[객체지향의 사실과 오해] - 3"

excerpt: "객체지향의 사실과 오해"
categories: [Book, 객체지향의 사실과 오해]
tags: [Book, 객체지향의 사실과 오해]
date: 2023-09-19
last_modified_at: 2023-09-19
render_with_liquid: false
---
# 03 타입과 추상화

3장에서는 해리 벡이 디자인한 현재의 지하철 노선도로 추상화라는 개념을 소개하며 2장에 이어 이상한 나라의 앨리스로 추상화를 보다 자세히 풀어나간다.

### 추상화

**__지하철 노선도_**

![](https://velog.velcdn.com/images/yeondori/post/30779415-c64f-49a8-9a4b-85f0ed7cc629/image.png)

지하철 노선도에서 승객이 얻고자 하는 것은 어떤 역에서 출발하고 환승해야 하며 어떻게 가장 쉽고 빠르게 목적지에 도착할 수 있는지를 **직관적**이고 **단순**하게 보여주는 것이다.

좌측의 그림과 같이 실제와 유사하게 물리적 지형과 거리를 묘사하는 방식은 '**이동**' 이라는 본래 목적과는 무관한 사실적 지형 정보를 혼합해 오히려 역과 역 사이의 연결성이라는 중요한 정보를 파악할 수 없게 만든다. 반면 과감하게 사실적으로 묘사하는 '**정확성**'을 배제하고 단순히 역과 역 사이에 연결성이라는 '**목적**'을 고려한다면 보다 이해하기 쉽고 단순하며 목적에 부합한 지하철 노선도를 창조해 낼 수 있게 된다.

승객이 꼭 알아야 하는 사실만 정확하게 표현하고, 몰라도 되는 정보는 무시함으로써 지하철 노선도를 **추상화**한 것이다.

현실의 복잡성을 이해하기에 인간의 인지 능력과 저장 공간은 매우 부족하므로, 사람들은 본능적으로 이해하기 쉽고 예측 가능한 수준으로 현실을 분해하고 단순화한다. 이때 **추상화**란 현실에서 출발하되, 불필요한 부분을 도려내 가며 사물의 놀라운 본질을 드러내는 과정이라고 할 수 있으며, 추상화의 목적은 불필요한 부분을 무시함으로써 현실에 있는 복잡성을 극복하는, 인간의 가장 기본적인 인지 수단이라고 할 수 있다.

책에서는 **추상화**를 다음과 같이 정의한다.

> 어떤 양상, 세부 사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법

복잡성을 다루기 위해 추상화는 다음의 두 차원에서 이루어진다.

- 구체적인 사물들 간의 **공통점**은 취하고 차이점은 버리는 **일반화**를 통해 단순하게 만든다.
- 중요한 부분을 강조하기 위해 **불필요한 세부 사항을 제거**함으로써 단순하게 만든다.

객체지향 세계에서도 마찬가지로, 구체적이고 실제적인 수많은 객체들을 개별적인 단위로 취급하기에는 인간의 인지능력은 턱없이 부족하다, 따라서 사람들은 본능적으로 공통적인 특성을 기준으로 객체를 여러 그룹으로 묶어 동시에 다뤄야 하는 가짓수를 줄임으로써 상황을 단순화하려고 노력한다.

### 개념

**__이상한 나라의 앨리스_**

앨리스는 이야기에서 등장하는 정원사, 클로버 병사, 신하들, 공주와 왕자, 왕과 왕비 모두를 몸이 납작하고 네모난 몸 모서리에 팔다리가 달려있는, '기껏해야 트럼프에 불과하다'고 생각하며 이들을 '트럼프'라는 개념으로 단순화해서 바라보고 있다.

이처럼 공통점을 기반으로 객체를 묶기 위한 그릇을 **개념(concept)** 이라고 하는데 일반적으로 우리가 인식하고 있는 다양한 사물이나 객체에 적용하는 아이디어나 관념을 뜻한다. 개념을 이용하면 객체를 여러 그룹으로 분류(classification)할 수 있게 된다.

이때, **분류**란 객체에 특정한 개념을 적용해 객체 집합에 포함시키거나 제외하는 작업을 뜻한다. 객체에 특정한 개념을 적용하기로 결심했을 때 우리는 그 객체를 특정한 집합의 멤버로 분류하고 있는 것이다.

각 객체는 특정한 개념을 표현하는 그룹의 일원으로 포함되며 이처럼 객체에 어떤 개념을 적용하는 것이 가능해서 개념 그룹의 일원이 될 때, 객체를 그 개념의 인스턴스라고 한다.
즉, 객체란 특정한 개념을 적용할 수 있는 구체적인 사물을 의미하고 개념이 객체에 적용됐을 때 객체를 개념의 인스턴스라고 한다.

객체의 분류 장치로서 개념을 이야기할 때는 아래의 세 가지 관점을 함께 언급한다.

- **심볼(symbol)**: 개념을 가리키는 간략한 이름이나 명칭

  `위의 앨리스 이야기에서 개념을 지칭하는데 '트럼프'라는 이름을 사용한다.`
- **내연(intension)**: 개념의 완전한 정의를 나타내며 내연의 의미를 이용해 객체가 개념에 속하는지 여부를 확인할 수 있다.

  `몸이 납작하고 두 손과 두 발이 네모 귀퉁이에 달려 있다.`
- **외연(extension)**: 개념에 속하는 모든 객체의 집합

  `정원사, 병사, 신하, 왕자와 공주, 왕과 왕비들 등`

개념을 이용해 공통점을 가진 객체들을 분류할 수 있다는 아이디어는 객체지향 패러다임이 복잡성을 극복하는 데 사용하는 가장 기본적인 인지 수단이다.

객체를 적절한 개념에 따라 분류하지 못하는 경우 유지보수가 어렵고 변화에 쉽게 대처하지 못하므로, 어떤 객체를 어떤 개념으로 분류할지가 객체지향의 품질을 결정한다.

### 타입

개념의 정의와 동일하며, 공통점을 기반으로 객체들을 묶기 위한 틀이다.

**타입 시스템**은 컴퓨터 속의 데이터를 목적에 따라 분류하는 것으로,
메모리 안의 모든 데이터가 비트열로 보임으로써 데이터가 잘못 사용되는 혼란을 방지하기 위해 제약 사항을 부과하는 것이다.

**데이터 타입**은 메모리 안에 저장된 데이터의 종류를 분류하는 데 사용하는 메모리 집합에 관한 메타데이터다. 데이터에 대한 분류는 암시적으로 어떤 종류의 연산이 해당 데이터에 대해 수행될 수 있는지를 결정한다.(어떤 데이터에 어떤 연산자를 적용할 수 있느냐가 데이터의 타입을 결정한다)

데이터 타입에서의 타입과 객체지향에서의 타입은 깊은 연관성이 있는데, 프로그램을 작성할 때 우리는 객체를 일종의 데이터처럼 사용하므로 객체를 타입에 따라 분류하고 그 타입에 이름을 붙이는 것은 결국 프로그램에서 사용할 데이터 타입을 선언하는 것과 같다. 또한 데이터 타입과 객체의 타입 모두 객체가 수행하는 행동에 따라 객체가 어떤 타입에 속하는지가 결정되며, 객체의 내부 표현은 외부로부터 감춰진다.

그러나 객체는 데이터가 아니며 객체에서 중요한 것은 객체의 행동임을 항상 유의하여야 한다.

어떤 객체가 어떤 타입에 속하는지를 결정하는 것은 객체가 수행하는 행동이다. 동일한 행동을 수행할 수 있다면 그 객체들은 동일한 타입으로 분류될 수 있으며 객체가 어떤 데이터를 보유하고 있는지는 타입을 결정하는 데 영향을 미치지 않는다. 동일한 타입에 속한 객체는 내부의 데이터 표현 방식이 다르더라도 동일한 메시지를 수신하고 이를 처리할 수 있다. 다만 내부의 표현 방식이 다르기 때문에 동일한 메시지를 처리하는 방식은 서로 다를 수 밖에 없는데 **다형성**이란 동일한 요청에 대해 서로 다른 방식으로 응답할 수 있는 능력을 뜻한다.

객체의 내부적인 표현은 외부로부터 철저하게 감춰진다. 객체의 행동을 가장 효과적으로 수행할 수만 있다면 객체 내부의 상태를 어떤 방식으로 표현하더라도 무방하다. 훌륭한 객체지향 설계는 외부에 행동만을 제공하고 데이터는 행동 뒤로 감춰야 한다. (**캡슐화**)

행동에 따라 객체를 분류하기 위해서는 객체가 내부적으로 관리해야 하는 데이터가 아닌 객체가 외부에 제공해야 하는 행동을 먼저 생각해 외부에 제공해야 하는 책임을 먼저 결정하고, 그 책임을 수행하는 데 적합한 데이터를 나중에 결정한 후에 데이터를 외부 인터페이스 뒤로 캡슐화해야 한다.

#### 일반화/특수화 관계

타입과 타입 간에는 일반화/특수화 관계가 존재할 수 있다. 일반적이라는 말은 더 포괄적이라는 의미를 내포하며, 특수하다는 것은 일반적인 개념보다 범위가 더 좁다는 것을 의미하므로 일반적인 개념의 부분집합이 된다. 이때, 이러한 일반화/특수화 관계를 결정하는 것은 객체의 상태를 표현하는 데이터가 아니라 **행동**이라는 점이 중요하다.
![](https://velog.velcdn.com/images/yeondori/post/95cfd9d7-debc-4900-9c07-99aa840c8a0b/image.png)

#### 슈퍼타입과 서브타입

좀더 일반적인 타입을 **슈퍼타입(Supertype)** 이라고 하고 좀 더 특수한 타입을 **서브타입(Subtype)** 이라고 한다. 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행위적 호환성을 만족시켜아 한다. 일반적으로 서브타입은 슈퍼타입의 행위와 호환되기 때문에 서브타입은 슈퍼타입을 대체할 수 있어야 한다.

![](https://velog.velcdn.com/images/yeondori/post/7e4aa617-18c7-46bd-9f23-4ade21bea28c/image.png)

일반화/특수화 계층은 불필요한 세부 사항을 제거해 단순하게 만드는 추상화의 두번째 차원을 적절하게 활용하는 대표적인 예이기도 하다. 타입을 사용하는 이유는 인간의 인지 능력으로는 시간에 따라 동적으로 변하는 객체의 복잡성을 극복하기가 너무 어렵기 때문인데, 타입은 시간에 따라 동적으로 변하는 상태를 시간과 무관한 정적인 모습으로 다룰 수 있게 해준다. 어떤 시점에 관해 생각할 때 불필요한 시간이라는 요소와 상태 변화라는 요소를 제거하고 철저하게 정적인 관점에서 객체를 묘사하는 것을 가능하게 해주므로 타입은 추상화이다.

#### 동적 모델과 정적 모델

객체를 생각할 때 우리는 두 가지 모델을 동시에 고려한다.

1. **동적 모델(dynamic model)**
   객체가 살아 움직이는 동안 상태가 어떻게 변하고 어떻게 행동하는지를 포착하는 것. 객체가 특정 시점에 구체적으로 어떤 상태를 가지느냐에 관한 것. (객체의 스냅샷)
2. **타입 모델(type model)**
   객체가 가질 수 있는 모든 상태와 모든 행동을 시간에 독립적으로 표현하는 것. 동적으로 변하는 객체의 상태가 아니라 객체가 속한 타입의 정적인 모습을 표현하기 때문에 **정적 모델(static model)** 이라고도 한다.

객체지향 애플리케이션을 설계하고 구현할 때는 두 모델을 적절히 혼용해야 한다. 클래스를 작성하는 시점에는 시스템을 정적인 관점에서 접근하나, 실제로 애플리케이션을 실행해 객체의 상태 변경을 추적하고 디버깅하는 동안에는 객체의 동적인 모델을 탐험하게 된다.

정리하자면, 객체지향에서 중요한 것은 동적으로 변하는 객체의 '상태'와 상태를 변경하는 '행위'다. 객체를 분류하는 기준은 타입이며, 타입을 나누는 기준은 객체가 수행하는 **행동**이다. 클래스는 타입을 구현할 수 있는 여러 매커니즘 중 하나이며 이를 잘 구분하는 것이 설계를 유연하게 유지하기 위한 바탕이 된다.
객체가 협력을 위해 어떤 책임을 지녀야 하는지를 결정하는 것이 객체지향 설계의 핵심이다.
