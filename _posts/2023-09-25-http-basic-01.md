---
title: "[강의] 모든 개발자를 위한 HTTP 웹 기본 지식 01-02"
excerpt: "인프런 강의 복습"
categories: [Inflearn, HTTP-Basic]
tags: [HTTP]
date: 2023-09-25
last_modified_at: 2023-09-25
render_with_liquid: false
---

# 모든 개발자를 위한 HTTP 웹 기본 지식 [강의](https://www.inflearn.com/course/http-%EC%9B%B9-%EB%84%A4%ED%8A%B8%EC%9B%8C%ED%81%AC)

김영한님의 인프런 강의(모든 개발자를 위한 HTTP 웹 기본 지식) 을 수강하면서 강의 내용을 일부 발췌해 요약한 글.

## **섹션 1** 인터넷 네트워크

- 인터넷 통신
- IP(Internet Protocol)
- TCP, UDP
- PORT
- DNS

웹, http 모두 결국 인터넷 네트워크 기반으로 동작하므로 http 학습을 위해선 인터넷 네트워크에 대한 기본 학습이 필요하다.

### **인터넷 통신**

물리적으로 떨어져 있는 컴퓨터 두 대는 인터넷에서 어떻게 통신할 수 있을까? 복잡한 인터넷 망에서 메시지는 수많은 노드를 거쳐 어떤 규칙으로 전달되는 지를 이해하려면 **IP(Internet Protocol)**를 먼저 알아야 한다. 


### **IP**

IP는 지정한 IP 주소에 데이터를 전달할 수 있도록 하는 규칙이며 패킷(Packet)이라는 통신 단위로 데이터가 전달된다. 데이터를 전송하는 측을 클라이언트, 수신하는 측을 서버라고 하자. 
클라이언트는 전송하고자 하는 데이터를 출발지 IP와 목적지 IP를 포함해 IP 패킷에 담아 서버에게 전달하고, 패킷을 전달받은 서버는 동일한 방식으로 OK 패킷을 클라이언트에게 전달한다.
그러나 이러한 방식만으로는 다음과 같은 한계가 있다.

- **비연결성** 

    패킷을 받을 대상이 없거나 서비스 불능 상태여도 패킷을 전송할 수 있다.


- **비신뢰성**

    중간에 패킷이 사라지거나 패킷이 순서대로 도착하지 않는 경우가 발생할 수 있다.


- **프로그램 구분**

    같은 IP를 사용하는 서버에서 통신하는 애플리케이션이 둘 이상일 수 있다. 


이러한 문제를 해결해주는 것이 TCP이다.

### **TCP, UDP**


![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/15a26373-3aee-490b-81fe-163228d49e5a)

**TCP**
앞선 문제를 해결하기 위해 IP 패킷 안에 출발지 port, 목적지 port, 전송 제어, 순서 검증 정보 등 TCP 관련 정보가 추가된다.

TCP는 전송 제어 프로토콜(Transmission Control Protocol)로 신뢰할 수 있는 프로토콜이며, 현재는 대부분의 애플리케이션에서 TCP를 사용한다. TCP는 다음과 같은 특징이 있다.

- **연결지향 - TCP 3 way handshake (가상 연결)**

  TCP 3 way handshake는 1. 클라이언트에서 서버로 SYN(접속 요청), 2. 서버에서 클라이언트로 SYN + ACK(요청 수락), 3. 클라이언트가 서버로 ACK 하는 세 번의 메시지 전달 과정으로 연결이 된다. 그러나 이때의 연결은 물리적인 연결이 아닌 논리적인 **가상 연결**이다.
  이러한 방식으로 연결이 된 후에야 데이터를 전송하기 때문에 연결이 없는 상태에서는 패킷을 전송하지 않는다. 참고로 현재는 최적화되어 3번 ACK와 함께 데이터 전송이 가능하다. 
  

- **데이터 전달 보증**
  
  TCP에서는 데이터를 전송하면 서버에서 데이터를 받은 경우 이를 알려준다. 따라서 만약 요청이 전송되었는데 서버에서 응답이 없다면, 메시지가 전달 도중 누락이 되었다고 알 수 있게 된다. 

- **순서 보장**

  클라이언트에서 보낸 순서대로 패킷이 오지 않은 경우, 서버에서는 순서가 잘못된 부분부터 패킷을 다시 요청한다. 


이러한 특징은 모두 TCP 패킷 내부에 출발지 port, 목적지 port, 전송 제어, 순서 검증 정보 등 TCP 관련 정보가 포함되어 있기 때문에 가능하다.

**UDP**
UDP는 TCP와 같이, IP 계층 바로 위에 있는 프로토콜이지만 기능이 거의 없다.
IP와 거의 같으나 PORT와 체크섬(데이터 검증) 정도만 추가된 정도이기 때문에, 이미 많이 구축되어 있어 최적화가 어려운 TCP와는 달리, 최적화하고자 할 때 사용된다.

### **PORT**

만약 하나의 클라이언트에서 한번에 둘 이상을 연결해야 한다면 어떨까? 여러 서버에서 오는 패킷을 어떻게 구분할까? 앞선 TCP 설명에서 TCP/IP 패킷에는 출발지/목적지의 IP뿐만 아니라 PORT가 포함되어 있다. 
IP는 목적지 서버를 찾는 것이라면, PORT는 해당 서버에서 돌아가는 애플리케이션을 구분하는 것, 즉, IP 내에서 프로세스를 구분해주는 것이라고 생각하면 된다.

0 ~ 65535에 할당이 가능한데, 0 ~ 1023은 잘 알려진 포트로, 사용하지 않는 것이 좋다. 참고로 FTP(20,21), TELNET(23), HTTP(80), HTTPS(443)을 사용한다.

### **DNS**

IP는 기억하기 매우 어려우며 변경될 수 있다. **DNS(Domain Name System)**은 이 두 가지 문제를 해결해주는 시스템으로, DNS 서버는 도메인 명을 IP주소로 변환하고, 변경되는 IP주소도 관리해준다. 
전화번호부라고 생각하면 이해가 쉽다.


## **섹션 2** URI와 웹 브라우저 요청 흐름
### **URI(Uniform Resource Identifier)**
![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/d548cce4-3b8c-481f-974c-b231c630723c)
![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/18d8f1d9-f1d7-47fb-af01-a3df2c41216a)

URI는 로케이터(locator), 이름(name) 또는 둘다 추가로 분류될 수 있는 포괄적인 개념으로, 인터넷상의 리소스 “자원 자체”를 식별하는 고유한 문자열 시퀀스이다.
(강의에서는 앞으로 편의상 URI와 URL을 같은 의미로 이야기하겠음을 밝힘)

**URL의 전체 문법**은 다음과 같다.

![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/ed95b08b-6736-4ab6-af3c-7ea925f691ac)

- **schema** - 스키마에는 주로 프로토콜이 사용되며, 프로토콜은 http, https 등 어떤 방식으로 자원에 접근할 것인가 하는 약속 규칙이다. 
- **userinfo/host** -  userinfo는 거의 사용되지 않으며, host는 보통 host명이나 도메인명 또는 ip주소를 직접 사용이 가능하다.
- **port** - 생략 가능하다
- **path** - 리소스가 있는 경로를 뜻하며, 보통 계층적 구조로 설계한다. 
- **query** - key=value의 형태로 ?로 시작하고 &로 파라미터 추가가 가능하다. 보통 query parameter 또는 query string으로 불린다.
- **fragment** - 잘 사용하진 않으며 html 내부 북마크 등에 사용하고 서버에 전송하는 정보는 아니다.

### **웹 브라우저 요청 흐름**

https://www.google.com/search?q=hello&hl=ko 를 검색한다고 했을 때 흐름은 다음과 같다.

1. 입력받은 주소를 DNS 서버에 조회하여 대응하는 IP와 PORT를 찾아낸다.
2. 웹 브라우저가 HTTP 요청 메시지를 생성한다. HTTP 요청 메시지는 메소드와 쿼리, HTTP 버전 정보와 호스트 정보 등으로 구성되어 있다.
3. SOCKET 라이버리를 통해 TCP/IP 계층과 연결(3 way ~)한 뒤, 데이터를 전달한다.
4. TCP/IP 패킷 생성, 이때 TCP/IP에는 출발지/목적지의 IP와 PORT, 그리고 전송 데이터인 HTTP 메시지가 포함된다.
5. 요청 패킷을 구글 서버에게 전달한다.
6. 패킷을 받은 구글 서버는 메시지를 보고 해당하는 데이터를 찾아 응답 메시지를 생성한다. HTTP 응답 메시지는 HTTP 버전과 상태 코드, Content-Type(컨텐츠 형식), Content-length 등을 포함한다.
7. 응답 메시지가 포함된 응답 패킷을 웹브라우저에게 전달한다.
8. 웹 브라우저에 응답 패킷이 도착하면 HTTP 메시지를 렌더링한다. 우리는 렌더링된 결과를 본다.

