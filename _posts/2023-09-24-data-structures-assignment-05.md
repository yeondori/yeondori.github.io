---
title: "[ë°ì´í„° êµ¬ì¡°ë¡ ][ê³¼ì œ] 05 ìŠ¤ë„ì¿  Naked Single"

excerpt: "ë°ì´í„° êµ¬ì¡°ë¡  ê³¼ì œ"
categories: [ERICA, Data Structures]
tags: [C++, Data Structures]
date: 2023-09-24
last_modified_at: 2023-09-24
render_with_liquid: false
---
# ìŠ¤ë„ì¿  - Naked Single

## 2019-10-6

### í”„ë¡œê·¸ë¨ ë¦¬ìŠ¤íŠ¸

```cpp
#include<iostream>
using namespace std;

struct cell {
	int candidate[9];
	int sol;
	int count;
	int box;
};

struct hint_cell {
	int sol;
	int row;
	int col;
	int box;
};

void pop(hint_cell st[81], int& top) {
	top--;
}

void push(cell sudoku[][9], hint_cell st[81], int& top) {
	for (int i = 0; i < 9; i++) {
		for (int j = 0; j < 9; j++) {
			if (sudoku[i][j].count == 1) {
				for (int k = 0; k < 9; k++) {
					if (sudoku[i][j].candidate[k] == 0) {
						sudoku[i][j].sol = k + 1;
						sudoku[i][j].candidate[k] = 1;
						st[top] = { k + 1, i ,j, sudoku[i][j].box };
						top++;
					}
				}
			}
		}
	}
}

void row_cross_out(cell sudoku[][9], hint_cell st[81], int top){
	int pos = st[top].sol - 1;
	for (int i = 0; i < 9; i++)  {
		for (int j = 0; j < 9; j++)  {
			if (st[top].row == i && sudoku[i][j].sol == 0)  {
				if (sudoku[i][j].candidate[pos] == 0)  {
					sudoku[i][j].candidate[pos] = 1;
					sudoku[i][j].count--;
				}
			}
		}
	}
}

void col_cross_out(cell sudoku[][9], hint_cell st[81], int top)  {
	int pos = st[top].sol - 1;
	for (int i = 0; i < 9; i++)  {
		for (int j = 0; j < 9; j++)  {
			if (st[top].col == j && sudoku[i][j].sol == 0) {
        if (sudoku[i][j].candidate[pos] == 0)  {
					sudoku[i][j].candidate[pos] = 1;
					sudoku[i][j].count--;
				}
			}
		}
	}
}

void box_cross_out(cell sudoku[][9], hint_cell st[81], int top)  {
	int pos = st[top].sol - 1;
	for (int i = 0; i < 9; i++)  {
		for (int j = 0; j < 9; j++)  {
			if (st[top].box == sudoku[i][j].box && sudoku[i][j].sol == 0)  {
				if (sudoku[i][j].candidate[pos] == 0)  {
					sudoku[i][j].candidate[pos] = 1;
					sudoku[i][j].count--;
				}
			}
		}
	}
}


void print(cell sudoku[][9])  {
	for (int i = 0; i < 9; i++)  {
		for (int j = 0; j < 9; j++)  {
			cout << sudoku[i][j].sol << " ";

			if (j % 9 == 8)  {
				cout << endl;
			}
		}
	}
}

void print_count(cell sudoku[][9])  {
	for (int i = 0; i < 9; i++)  {
		for (int j = 0; j < 9; j++)  {
			cout << sudoku[i][j].count << " ";

			if (j % 9 == 8)  {
				cout << endl;
			}
		}
	}
}

int main()  {
	cell sudoku[9][9] = { {{{0},0,9,1}, {{0},0,9,1}, {{0},0,9,1}, {{0},0,9,2}, {{1},8,0,2}, {{1},3,0,2}, {{0},0,9,3}, {{0},0,9,3}, {{0},0,9,3}},
						  {{{1},7,0,1}, {{0},0,9,1}, {{0},0,9,1}, {{0},0,9,2}, {{1},6,0,2}, {{0},0,9,2}, {{0},0,9,3}, {{1},9,0,3}, {{1},8,0,3}},
						  {{{1},9,0,1}, {{0},0,9,1}, {{1},8,0,1}, {{1},7,0,2}, {{0},0,9,2}, {{0},0,9,2}, {{0},0,9,3}, {{0},0,9,3}, {{0},0,9,3}},
						  {{{0},0,9,4}, {{0},0,9,4}, {{1},1,0,4}, {{1},3,0,5}, {{0},0,9,5}, {{0},0,9,5}, {{1},8,0,6}, {{0},0,9,6}, {{0},0,9,6}},
						  {{{1},5,0,4}, {{1},9,0,4}, {{0},0,9,4}, {{1},1,0,5}, {{1},7,0,5}, {{1},8,0,5}, {{0},0,9,6}, {{1},3,0,6}, {{1},4,0,6}},
						  {{{0},0,9,4}, {{0},0,9,4}, {{1},3,0,4}, {{0},0,9,5}, {{0},0,9,5}, {{1},2,0,5}, {{1},9,0,6}, {{0},0,9,6}, {{0},0,9,6}},
						  {{{0},0,9,7}, {{0},0,9,7}, {{0},0,9,7}, {{0},0,9,8}, {{0},0,9,8}, {{1},7,0,8}, {{1},4,0,9}, {{0},0,9,9}, {{1},2,0,9}},
						  {{{1},8,0,7}, {{1},2,0,7}, {{0},0,9,7}, {{0},0,9,8}, {{1},9,0,8}, {{0},0,9,8}, {{0},0,9,9}, {{0},0,9,9}, {{1},7,0,9}},
						  {{{0},0,9,7}, {{0},0,9,7}, {{0},0,9,7}, {{1},5,0,8}, {{1},2,0,8}, {{0},0,9,8}, {{0},0,9,9}, {{0},0,9,9}, {{0},0,9,9}} };

	hint_cell st[81] = { {2,8,4,8}, {5,8,3,8}, {7,7,8,9}, {9,7,4,8}, {2,7,1,7}, {8,7,0,7}, {2,6,8,9}, {4,6,6,9}, {7,6,5,8}, {9,5,6,6}
					   , {2,5,5,5}, {3,5,2,4}, {4,4,8,6}, {3,4,7,6}, {8,4,5,5}, {7,4,4,5}, {1,4,3,5}, {9,4,1,4}, {5,4,0,4}, {8,3,6,6}
					   , {3,3,3,5}, {1,3,2,4}, {7,2,3,2}, {8,2,1,1}, {9,2,0,1}, {8,1,8,3}, {9,1,7,3}, {6,1,4,2}, {7,1,0,1}, {3,0,5,2}
					   , {8,0,4,2} };
	int top = 31;

	print(sudoku);
	cout << endl << endl << "soluiton : " << endl << endl;
	while (top > 0)  {
		pop(st, top);
		row_cross_out(sudoku, st, top);
		col_cross_out(sudoku, st, top);
		box_cross_out(sudoku, st, top);
		push(sudoku, st, top);
	}
	print(sudoku);
	cout << endl << endl << "candidate : " << endl << endl;
	print_count(sudoku);
	return 0;
}


```

### ì¶œë ¥ ê²°ê³¼

![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/ea93e89c-5b0d-40ee-91ba-4b9eb2742de1)
ìˆœì„œëŒ€ë¡œ cross out ì „ì˜ ìŠ¤ë„ì¿ , cross out í›„ì˜ ìŠ¤ë„ì¿ , ìŠ¤ë„ì¿ ì˜ candidate

### ì†Œê°ë¬¸

ì´ë²ˆ ì£¼ì˜ ê³¼ì œëŠ” ëŒ€ë§ì˜ ìŠ¤ë„ì¿ ì˜€ìŠµë‹ˆë‹¤. ì½”ë”©ì„ í•˜ê¸° ì•ì„œ, ì €ëŠ” ìŠ¤ë„ì¿ ë¥¼ ì§ì ‘ í’€ì–´ë³´ì•˜ìŠµë‹ˆë‹¤. íˆë“  ì‹±ê¸€ì„ ìƒê°í•˜ì§€ ì•Šê³ , cross outë§Œ í•˜ë©´ì„œ naked singleì„ ì°¾ì•˜ìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ ëª‡ ë²ˆì„ í•´ë´ë„ naked singleì´ ë‚˜ì˜¤ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. í™”ìš”ì¼ í•˜ë£¨ ë™ì•ˆì€ naked singleë§Œ í•œ ê²ƒ ê°™ìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ ë™ê¸°ë“¤ì—ê²Œ ë§í•´ë³´ì•˜ë”ë‹ˆ ë‹¤ë“¤ naked singleì´ ë‚˜ì˜¤ì§€ ì•ŠëŠ”ë‹¤ê³  í•˜ì—¬, êµìˆ˜ë‹˜ê»˜ ë©”ì¼ì„ ë³´ëƒˆìŠµë‹ˆë‹¤. naked single ì½”ë“œë¥¼ ë§Œë“¤ê¸° ìœ„í•˜ì—¬ ì¸í„°ë„·ì—ì„œ naked singleë§Œìœ¼ë¡œë„ í’€ë¦¬ëŠ” ìŠ¤ë„ì¿ ë¥¼ ì°¾ì•„ ì½”ë“œë¥¼ ì‘ì„±í•´ë³´ì•˜ìŠµë‹ˆë‹¤. ìš°ì„ , ì•Œê³ ë¦¬ì¦˜ì€ ì´ë ‡ìŠµë‹ˆë‹¤. candidate ë°°ì—´ì„ ëª¨ë‘ 0ìœ¼ë¡œ ì´ˆê¸°í™”í•œ ë’¤, cross outì„ ì§„í–‰í•˜ì—¬ íŒíŠ¸ì™€ ëŒ€ì‘í•˜ëŠ” candidate ìœ„ì¹˜ì— 0 ëŒ€ì‹  1ì„ ëŒ€ì…í•˜ê³ , countë¥¼ ì¤„ì˜€ìŠµë‹ˆë‹¤. ì´ëŸ¬í•œ ê³¼ì •ì„ ë§ˆì¹œ ë’¤, countê°€ 1ì´ ëì„ ë•Œ(ì¦‰, candidate ë°°ì—´ ì†ì—ëŠ” 0ì¸ ë¶€ë¶„ì´ í•œ ìë¦¬ë°–ì— ì—†ìŒ), 0ì¸ ê³³ì˜ ìœ„ì¹˜ë¥¼ ì¶œë ¥í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ êµ¬ìƒí–ˆìŠµë‹ˆë‹¤. ì•Œê³ ë¦¬ì¦˜ì„ êµ¬ìƒí•˜ê³  ì½”ë“œë¥¼ ì‘ì„±í•˜ëŠ”ë°ëŠ” ê·¸ë ‡ê²Œ ì˜¤ëœ ì‹œê°„ì´ ê±¸ë¦¬ì§€ ì•Šì•˜ì§€ë§Œ, êµ¬í˜„í•˜ëŠ” ë° ì˜¤ë¥˜ê°€ ìˆì–´ ìŠ¤ë„ì¿ ë¥¼ ì™„ì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. whileë¬¸ì´ ëë‚˜ì§€ ì•Šì„ ë•Œë„ ìˆì—ˆê³ , ì˜ëª»ëœ ê°’ì´ ëŒ€ì…ë  ë•Œë„ ìˆì—ˆê³ , ì²« ë²ˆì§¸ naked singleì´ ëœ ë‚˜ì˜¤ëŠ” ê²½ìš°ë„ ìˆì—ˆìŠµë‹ˆë‹¤. ê·¸ë˜ì„œ cross out í•¨ìˆ˜ë¥¼ ì˜ê²Œ ìª¼ê°œê³ , ë¶€ë¶„ë§ˆë‹¤ coutìœ¼ë¡œ ì§„í–‰ìƒí™©ì„ í™•ì¸í•˜ì˜€ìŠµë‹ˆë‹¤. ê·¸ ê²°ê³¼, ì˜¤ë¥˜ëŠ” íŒíŠ¸ ì…€ í•˜ë‚˜ë¥¼ ì˜ëª» ì…ë ¥í–ˆê¸° ë•Œë¬¸ì— ë°œìƒí–ˆë‹¤ëŠ” ê²ƒì„ íŒŒì•…í•  ìˆ˜ ìˆì—ˆìŠµë‹ˆë‹¤. ë§ì´ ì‰½ì§€ ì‚¬ì‹¤ ì˜¤ë¥˜ í•˜ë‚˜ë¥¼ ë°œê²¬í•˜ëŠ” ë° 2ì¼ì´ ê±¸ë ¸ê³ , ì§€ê¸ˆë„ ê¸‰í•˜ê²Œ ì†Œê°ë¬¸ì„ ì‘ì„±í•˜ê³  ìˆìŠµë‹ˆë‹¤. ìš¸ê¸° ì§ì „ì— ì˜¤ë¥˜ë¥¼ ë°œê²¬í•´ì„œ ì°¸ ë‹¤í–‰ì´ë¼ëŠ” ìƒê°ì´ ë“­ë‹ˆë‹¤. í•˜ê³  ì‹¶ì—ˆë˜ ë§ì´ ì •ë§ ë§ì•˜ì§€ë§Œ ì œì¶œ ì‹œê°„ì´ ë‹¤ê°€ì˜¤ê³  ìˆì–´ì„œ ì—¬ê¸°ê¹Œì§€ë§Œ í•˜ê² ìŠµë‹ˆë‹¤. ì•„ì§ê¹Œì§€ í•œ ë¼ë„ ëª» ë¨¹ì—ˆëŠ”ë° ë°¥ì„ ë¨¹ê³  ì™€ì„œ íˆë“  ì‹±ê¸€ì„ ìƒê°í•´ ë³¼ ì˜ˆì •ì…ë‹ˆë‹¤. ì•„ë˜ ì²¨ë¶€í•œ ì‚¬ì§„ì€ ì œ ê³ ë¯¼ì˜ í”ì ì…ë‹ˆë‹¤â€¦
![image](https://github.com/yeondori/yeondori.github.io/assets/93027942/aeb43f16-8817-4a38-92ce-68903551d8a3)

## 2023-09-24

ì• ì¦ì˜ ìŠ¤ë„ì¿ ! ë§¤ì¼ë§¤ì¼ ìˆ˜ì—… ëë‚˜ë©´ ë†€ë¦¬ì§€íŒ©í† ë¦¬ë¡œ ë‹¬ë ¤ê°€ì„œ ìë¦¬ ì¡ê³  ìŠ¤ë„ì¿ ë§Œ ì£¼êµ¬ì¥ì°½ ë¶™ì¡ê³  ìˆë˜ ê³¼ê±° ê·¸ ì‹œì ˆì€ ëª‡ë…„ì´ ì§€ë‚˜ë„ ìŠì§€ ëª»í•  ê±°ê³ ,, C++ì„ D+ ë§ì€ ì‹¤ë ¥ìœ¼ë¡œ ì´ê±¸ í•´ëƒˆë‹¤ëŠ” ê²Œ ì•„ì§ë„ ë„ˆë¬´ë‚˜ ìë‘ìŠ¤ëŸ½ê³  ëŒ€ê²¬í•˜ë‹¤ğŸ¥²
ë„¤ì´í‚¤ë“œ ì‹±ê¸€ì€ ë‹µì„ ì°¾ê³ ì í•˜ëŠ” í•´ë‹¹ ì…€ì— ëŒ€í•´ í–‰ê³¼ ì—´, ê·¸ë¦¬ê³  ê·¸ ì…€ì´ ì†í•´ ìˆëŠ” ë°•ìŠ¤(9*9) ë‚´ì— ë“±ì¥í•˜ì§€ ì•Šì€ ìˆ«ìê°€ ìœ ì¼í•  ë•Œë¥¼ ì˜ë¯¸í•œë‹¤. ì˜ˆë¥¼ ë“¤ì–´ ë‹¤ìŒì˜ ê·¸ë¦¼ì—ì„œ í–‰ê³¼ ì—´, ë°•ìŠ¤ê°€ êµì°¨í•˜ëŠ” ì§€ì ì—ì„œ ì˜¤ì§ 6ë§Œ í•´ë‹µì´ ë  ìˆ˜ ìˆë‹¤. ì´ëŸ¬í•œ ì…€ì„ ë„¤ì´í‚¤ë“œ ì‹±ê¸€ì´ë¼ê³  í•œë‹¤.

![image]((https://github.com/yeondori/yeondori.github.io/assets/93027942/1a67139e-b817-4392-8ca8-0bd086efc7e4) [ì°¸ê³ ](https://m.blog.naver.com/roty22/220697379898)

ìˆ˜í–‰ ìˆœì„œëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
- íŒíŠ¸ ìŠ¤íƒì—ì„œ Popìœ¼ë¡œ íŒíŠ¸ë¥¼ ê°€ì ¸ì˜¨ë‹¤.
- íŒíŠ¸ë¥¼ ë°”íƒ•ìœ¼ë¡œ í–‰ê³¼ ì—´, ë°•ìŠ¤ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ íƒìƒ‰í•œë‹¤.(cross out)) í•´ë‹¹ ì˜ì—­ì— ì¡´ì¬í•˜ëŠ” ìˆ«ìëŠ” ì •ë‹µì´ ë  ìˆ˜ ì—†ìœ¼ë¯€ë¡œ í•´ë‹¹ í›„ë³´êµ°ì—ì„œ ì†Œê±°í•œë‹¤. (êµ¬í˜„ ì½”ë“œì—ì„œëŠ” candidateë¼ëŠ” ë°°ì—´ì— í•´ë‹¹ ìˆ«ìì˜ ì¸ë±ìŠ¤ì— 1ì„ ë„£ê³  countë¥¼ ì¤„ì´ëŠ” ë°©ì‹)
- cross outì´ ëª¨ë‘ ëë‚˜ë©´ ì¹´ìš´íŠ¸ê°€ 1ì¸ ì…€ì˜ candidateë¥¼ í™•ì¸í•´ 0ì¸ ê³³ì˜ indexë¥¼ ë°”íƒ•ìœ¼ë¡œ ì†”ë£¨ì…˜ì„ ë“±ë¡í•˜ê³  íŒíŠ¸ ìŠ¤íƒì— í•´ë‹¹ ì…€ì„ pushí•œë‹¤.
- ìœ„ì™€ ê°™ì€ ê³¼ì •ì„ íŒíŠ¸ ìŠ¤íƒì„ ì „ë¶€ íƒìƒ‰í•  ë•Œê¹Œì§€ ë°˜ë³µí•œë‹¤.

